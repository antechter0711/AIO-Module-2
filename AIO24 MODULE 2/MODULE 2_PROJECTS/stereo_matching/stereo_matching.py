# -*- coding: utf-8 -*-
"""Stereo Matching

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fJQi44DhiQCIc2WYNaqvx36yiXIlmilP

Problem 1: Xây dựng hàm tính disparity map của hai ảnh stereo đầu vào (ảnh bên trái (L) và
ảnh bên phải (R)) theo phương thức pixel-wise matching.
"""

import cv2
import numpy as np

def distance(x, y):
    return abs(x - y)
def pixel_wise_matching(left_img, right_img, disparity_range, save_result=True):
    """
    Performs pixel-wise matching to compute a disparity map.

    Args:
        left_img: Path to the left image.
        right_img: Path to the right image.
        disparity_range: Maximum disparity value to consider.
        save_result: Whether to save the disparity map as an image.

    Returns:
        A numpy array representing the disparity map.
    """

    # Read images and convert to grayscale
    left = cv2.imread(left_img, 0).astype(np.float32)
    right = cv2.imread(right_img, 0).astype(np.float32)

    height, width = left.shape

    # Create disparity map
    depth = np.zeros((height, width), np.uint8)
    scale = 16  # Scale factor for visualization

    # Iterate over each pixel
    for y in range(height):
        for x in range(width):
            cost_min = np.inf
            disparity = 0

            # Calculate cost for different disparities
            for j in range(disparity_range):
                if x - j < 0:
                    cost = np.inf
                else:
                    cost = distance(left[y, x], right[y, x - j])

                if cost < cost_min:
                    cost_min = cost
                    disparity = j

            # Set disparity value at pixel (y, x)
            depth[y, x] = disparity * scale

    # Save disparity map as image
    if save_result:
        cv2.imwrite('pixel_wise_11.png', depth)
        cv2.imwrite('pixel_wise_11_color.png', cv2.applyColorMap(depth, cv2.COLORMAP_JET))

    return depth

left_img_path = '/content/left.png'
right_img_path = '/content/right.png'
disparity_range = 16

pixel_wise_result_l1 = pixel_wise_matching(
    left_img_path,
    right_img_path,
    disparity_range,
    save_result=True
)

# Saving result...
# Done.

pixel_wise_result_l2 = pixel_wise_matching(
    left_img_path,
    right_img_path,
    disparity_range,
    save_result=True
)

# Saving result...
# Done.

"""Problem 2: Xây dựng hàm tính disparity map của hai ảnh stereo đầu vào (ảnh bên trái (L)
và ảnh bên phải (R)) theo phương thức window-based matching.
"""

import cv2
import numpy as np

def distance(x, y):
    return abs(x - y)

left_img_path = '/Aloe/Aloe_left_1.png'
right_img_path = '/Aloe/Aloe_right_1.png'
disparity_range = 64
kernel_size = 3
def window_based_matching_l1(left_img, right_img, disparity_range, kernel_size, save_result=True):
    # Implementation of L1 cost function
    # Return disparity map

    # Read left, right images then convert to grayscale
    left = cv2.imread(left_img, 0)
    right = cv2.imread(right_img, 0)

    left = left.astype(np.float32)
    right = right.astype(np.float32)

    height, width = left.shape[:2]

    # Create blank disparity map
    depth = np.zeros((height, width), np.uint8)
    kernel_half = int((kernel_size - 1) / 2)
    scale = 3

    for y in range(kernel_half, height-kernel_half):
        for x in range(kernel_half, width-kernel_half):
            # Find j where cost has minimum value
            disparity = 0
            cost_optimal = float('inf')

            for j in range(disparity_range):
                d = x - j
                if (d - kernel_half) > 0:
                    wp = left[(y-kernel_half):(y+kernel_half)+1, (x-kernel_half):(x+kernel_half)+1]
                    wq = right[(y-kernel_half):(y+kernel_half)+1, (d-kernel_half):(d+kernel_half)+1]

                    # L1 cost function
                    cost = np.sum(np.abs(wp - wq))

                    if cost < cost_optimal:
                        cost_optimal = cost
                        disparity = j

            # Let depth at (y, x) = j (disparity)
            # Multiply by a scale factor for visualization purpose
            depth[y, x] = disparity * scale

    if save_result:
        print('Saving result...')
        # Save results
        cv2.imwrite('window_based_l1.png', depth)
        cv2.imwrite('window_based_l1_color.png', cv2.applyColorMap(depth, cv2.COLORMAP_JET))

    print('Done.')

    return depth

def window_based_matching_l2(left_img, right_img, disparity_range, kernel_size=5, save_result=True):
    # Read left, right images then convert to grayscale
    left  = cv2.imread(left_img, 0)
    right = cv2.imread(right_img, 0)

    left  = left.astype(np.float32)
    right = right.astype(np.float32)

    height, width = left.shape[:2]

    # Create blank disparity map
    depth = np.zeros((height, width), np.uint8)

    kernel_half = int((kernel_size - 1) / 2)
    scale = 3
    max_value = 255 ** 2

    for y in range(kernel_half, height-kernel_half):
        for x in range(kernel_half, width-kernel_half):

            # Find j where cost has minimum value
            disparity = 0
            cost_min  = 65534

            for j in range(disparity_range):
                total = 0
                value = 0

                for v in range(-kernel_half, kernel_half + 1):
                    for u in range(-kernel_half, kernel_half + 1):
                        value = max_value
                        if (x + u - j) >= 0:
                            value = l2_distance(int(left[y + v, x + u]),  int(right[y + v, (x + u) - j]))
                        total += value

                if total < cost_min:
                    cost_min = total
                    disparity = j

            # Let depth at (y, x) = j (disparity)
            # Multiply by a scale factor for visualization purpose
            depth[y, x] = disparity * scale

    if save_result == True:
        print('Saving result...')
        # Save results
        cv2.imwrite(f'window_based_l2.png', depth)
        cv2.imwrite(f'window_based_l2_color.png', cv2.applyColorMap(depth, cv2.COLORMAP_JET))

    print('Done.')

    return depth

left_img_path = '/content/Aloe_left_1.png'
right_img_path = '/content/Aloe_right_1.png'
disparity_range = 64
kernel_size = 3

left = cv2.imread(left_img_path)
right = cv2.imread(right_img_path)

# Check if images loaded successfully
if left is None:
    print(f"Error: Could not load image from {left_img_path}")
elif right is None:
    print(f"Error: Could not load image from {right_img_path}")
else:
    from google.colab.patches import cv2_imshow  # Import cv2_imshow if images loaded
    cv2_imshow(left)
    cv2_imshow(right)

depth = window_based_matching_l1(left_img_path, right_img_path, disparity_range,
                                 kernel_size=kernel_size, save_result=True)
cv2_imshow(depth)

"""Problem 3: Khi sử dụng hàm tính disparity map đã xây dựng ở Problem 2 cho cặp ảnh
Aloe_left_1.png và Aloe_right_2.png với tham số đầu vào disparity_range = 64 và kernel_size
= 5 ở cả hai hàm cost, ta được kết quả disparity map như ảnh minh họa sau:
"""

import cv2
import numpy as np

def distance(x, y):
    return abs(x - y)

left_img_path = '/Aloe/Aloe_left_1.png'
right_img_path = '/Aloe/Aloe_right_1.png'
disparity_range = 64
kernel_size = 5
def window_based_matching_l1(left_img, right_img, disparity_range, kernel_size, save_result=True):
    # Implementation of L1 cost function
    # Return disparity map

    # Read left, right images then convert to grayscale
    left = cv2.imread(left_img, 0)
    right = cv2.imread(right_img, 0)

    left = left.astype(np.float32)
    right = right.astype(np.float32)

    height, width = left.shape[:2]

    # Create blank disparity map
    depth = np.zeros((height, width), np.uint8)
    kernel_half = int((kernel_size - 1) / 2)
    scale = 3

    for y in range(kernel_half, height-kernel_half):
        for x in range(kernel_half, width-kernel_half):
            # Find j where cost has minimum value
            disparity = 0
            cost_optimal = float('inf')

            for j in range(disparity_range):
                d = x - j
                if (d - kernel_half) > 0:
                    wp = left[(y-kernel_half):(y+kernel_half)+1, (x-kernel_half):(x+kernel_half)+1]
                    wq = right[(y-kernel_half):(y+kernel_half)+1, (d-kernel_half):(d+kernel_half)+1]

                    # L1 cost function
                    cost = np.sum(np.abs(wp - wq))

                    if cost < cost_optimal:
                        cost_optimal = cost
                        disparity = j

            # Let depth at (y, x) = j (disparity)
            # Multiply by a scale factor for visualization purpose
            depth[y, x] = disparity * scale

    if save_result:
        print('Saving result...')
        # Save results
        cv2.imwrite('window_based_l1.png', depth)
        cv2.imwrite('window_based_l1_color.png', cv2.applyColorMap(depth, cv2.COLORMAP_JET))

    print('Done.')

    return depth

def window_based_matching_l2(left_img, right_img, disparity_range, kernel_size=5, save_result=True):
    # Read left, right images then convert to grayscale
    left  = cv2.imread(left_img, 0)
    right = cv2.imread(right_img, 0)

    left  = left.astype(np.float32)
    right = right.astype(np.float32)

    height, width = left.shape[:2]

    # Create blank disparity map
    depth = np.zeros((height, width), np.uint8)

    kernel_half = int((kernel_size - 1) / 2)
    scale = 3
    max_value = 255 ** 2

    for y in range(kernel_half, height-kernel_half):
        for x in range(kernel_half, width-kernel_half):

            # Find j where cost has minimum value
            disparity = 0
            cost_min  = 65534

            for j in range(disparity_range):
                total = 0
                value = 0

                for v in range(-kernel_half, kernel_half + 1):
                    for u in range(-kernel_half, kernel_half + 1):
                        value = max_value
                        if (x + u - j) >= 0:
                            value = l2_distance(int(left[y + v, x + u]),  int(right[y + v, (x + u) - j]))
                        total += value

                if total < cost_min:
                    cost_min = total
                    disparity = j

            # Let depth at (y, x) = j (disparity)
            # Multiply by a scale factor for visualization purpose
            depth[y, x] = disparity * scale

    if save_result == True:
        print('Saving result...')
        # Save results
        cv2.imwrite(f'window_based_l2.png', depth)
        cv2.imwrite(f'window_based_l2_color.png', cv2.applyColorMap(depth, cv2.COLORMAP_JET))

    print('Done.')

    return depth

left_img_path = '/content/Aloe_left_1.png'
right_img_path = '/content/Aloe_right_1.png'
disparity_range = 64
kernel_size = 5

left = cv2.imread(left_img_path)
right = cv2.imread(right_img_path)

# Check if images loaded successfully
if left is None:
    print(f"Error: Could not load image from {left_img_path}")
elif right is None:
    print(f"Error: Could not load image from {right_img_path}")
else:
    from google.colab.patches import cv2_imshow  # Import cv2_imshow if images loaded
    cv2_imshow(left)
    cv2_imshow(right)

depth = window_based_matching_l1(left_img_path, right_img_path, disparity_range,
                                 kernel_size=kernel_size, save_result=True)
cv2_imshow(depth)

import cv2
import numpy as np

def cosine_similarity(x, y):
    numerator = np.dot(x, y)
    denominator = np.linalg.norm(x) * np.linalg.norm(y)
    return numerator / denominator

def window_based_matching(left_img, right_img, disparity_range, kernel_size=5, save_result=True):
    # Read left, right images then convert to grayscale
    left = cv2.imread(left_img_path, 0)
    right = cv2.imread(right_img_path, 0)

    left = left.astype(np.float32)
    right = right.astype(np.float32)

    height, width = left.shape[:2]

    # Create blank disparity map
    depth = np.zeros((height, width), np.uint8)
    kernel_half = int((kernel_size - 1) / 2)
    scale = 3

    for y in range(kernel_half, height-kernel_half):
        for x in range(kernel_half, width-kernel_half):
            # Find j where cost has minimum value
            disparity = 0
            cost_optimal = -1

            for j in range(disparity_range):
                d = x - j
                if (d - kernel_half) > 0:
                    wp = left[(y-kernel_half):(y+kernel_half)+1, (x-kernel_half):(x+kernel_half)+1]
                    wqd = right[(y-kernel_half):(y+kernel_half)+1, (d-kernel_half):(d+kernel_half)+1]

                    wp_flattened = wp.flatten()
                    wqd_flattened = wqd.flatten()

                    cost = cosine_similarity(wp_flattened, wqd_flattened)

                    if cost > cost_optimal:
                        cost_optimal = cost
                        disparity = j

            # Let depth at (y, x) = j (disparity)
            # Multiply by a scale factor for visualization purpose
            depth[y, x] = disparity * scale

    if save_result == True:
        print('Saving result...')
        # Save results
        cv2.imwrite('window_based_cosine_similarity.png', depth)
        cv2.imwrite('window_based_cosine_similarity_color.png', cv2.applyColorMap(depth, cv2.COLORMAP_JET))

    print('Done.')
    return depth

depth = window_based_matching(left_img_path, right_img_path, disparity_range,
                                 kernel_size=kernel_size, save_result=True)
cv2_imshow(depth)
cv2_imshow(cv2.applyColorMap(depth, cv2.COLORMAP_JET))